#!/usr/bin/env node

var kss = require(__dirname + '/../lib/kss.js'),
	handlebars = require('handlebars'),
	cleanCSS = require('clean-css'),
	yargs = require('yargs'),
	marked = require('marked'),
	wrench = require('wrench'),
	async = require('async'),
	path = require('path'),
	fs = require('fs'),
	template,
	styleguide,
	generatePage,
	aggregateStylesheet,
	config = {},
	configFile,
	KSS_FAILED = false,
	argv,
	error,
	version = require(__dirname + '/../package.json').version,
	pathResolveRecursive;

/**
 * CLI argument parsing.
 * @type {Object}
 */
argv = yargs
	.usage('Usage: kss-node <source> [destination] [options]')
	.wrap(80)
	.strict()

	.options('init', {
		alias     : 'i',
		describe  : 'Create a new styleguide template to customize',
		default   : 'styleguide-template'
	})
	.options('template', {
		string    : true,
		alias     : 't',
		describe  : 'Use a custom template to build your styleguide',
		default   : path.relative(process.cwd(), __dirname + '/../lib/template')
	})
	.options('helpers', {
		string    : true,
		describe  : 'Specify the location of custom handlebars helpers; see http://bit.ly/kss-helpers',
		default   : path.relative(process.cwd(), __dirname + '/../lib/template/helpers')
	})

	.options('mask', {
		string    : true,
		alias     : 'm',
		describe  : 'Use a mask for detecting files containing KSS comments',
		default   : '*.css|*.less|*.sass|*.scss|*.styl|*.stylus'
	})
	.options('css', {
		string    : true,
		alias     : 's',
		describe  : 'Copies CSS stylesheets into the styleguide; WARNING: relative paths are not rewritten'
	})

	.options('source', {
		string    : true,
		describe  : 'Source directory to parse for KSS comments'
	})
	.options('destination', {
		string    : true,
		describe  : 'Destination directory of generated styleguide',
		default   : 'styleguide'
	})

	.config('config')
	.alias('config', 'c')
	.describe('config', 'Load the kss-node configuration from a json file')

	.options('xdemo', {
		boolean   : true,
		alias     : 'xdemo'
	})

	.version(version, 'version')
	.help('help')
	.alias('help', 'h')
	.alias('help', '?')
	.argv;

// Create a new styleguide template using the `--init` tag.
if ("init" in yargs.argv) {
	argv.init = path.resolve(argv.init);

	console.log('Creating a new styleguide template...');
	try {
		error = wrench.copyDirSyncRecursive(
			__dirname + '/../lib/template',
			argv.init,
			{
				forceDelete: false,
				excludeHiddenUnix: true
			}
		);
		if (error) {
			throw error;
		}
	} catch (e) {
		console.log('Error! This folder already exists: ' + argv.init);
		return;
	}
	console.log('You can change it as you like, and use it with your styleguide like so:');
	console.log('');
	console.log('kss-node [sourcedir] --template "'+argv.init+'"');
	console.log('');
	return;
}

// Determine which options are specified in a config json file.
if (argv.config) {
	configFile = path.resolve(argv.config);
	config = require(configFile);
	// Make config paths relative to config file.
	pathResolveRecursive = function(from, item) {
		var paths;
		if (item instanceof Array) {
			item.forEach(
				function(value, index) {
					paths[index] = path.resolve(from, value);
				}
			);
		}
		else {
			paths = path.resolve(path.dirname(configFile), item);
		}
		return paths;
	};
	for (var key in config) {
		argv[key] = pathResolveRecursive(path.dirname(configFile), config[key]);
	}
}
// Get the full source path.
if (argv.source instanceof Array) {
	argv.source = argv.source.pop();
}
else if (!("source" in yargs.argv) && argv._.length > 0) {
	argv.source = argv._[0];
}
else if (argv.xdemo) {
	argv.source = __dirname + '/../demo';
}
if (!argv.source) {
	yargs.showHelp();
	return;
}
argv.source = path.resolve(argv.source);
// Get the full destination path.
if (argv.destination instanceof Array) {
	argv.destination = argv.destination.pop();
}
else if (!("destination" in yargs.argv) && argv._.length > 1) {
	argv.destination = argv._[1];
}
argv.destination = path.resolve(argv.destination);
// Get the full template path.
if (argv.template instanceof Array) {
	argv.template = argv.template.pop();
}
argv.template = path.resolve(argv.template);
// Get the full helpers path.
if (argv.helpers instanceof Array) {
	argv.helpers = argv.helpers.pop();
}
else if (!("helpers" in yargs.argv) && !("helpers" in config)) {
	argv.helpers = argv.template + '/helpers';
}
argv.helpers = path.resolve(argv.helpers);

console.log('');
console.log('Generating your KSS Styleguide!');
console.log('');
console.log(' * KSS Source  : ' + argv.source);
console.log(' * Destination : ' + argv.destination);
console.log(' * Template    : ' + argv.template);
console.log(' * Helpers     : ' + argv.helpers);
console.log('');

// Create a new "styleguide" directory.
try {
	fs.mkdirSync(argv.destination);
} catch (e) {}

// Optionally copy the contents of "public" over.
try {
	wrench.copyDirSyncRecursive(
		argv.template + '/public',
		argv.destination + '/public',
		{
			forceDelete: true,
			excludeHiddenUnix: true
		}
	);
} catch (e) {}

// Ensure a "public" folder exists.
try {
	fs.mkdirSync(argv.destination + '/public');
} catch (e) {}

// Compile the Handlebars template
template = fs.readFileSync(argv.template + '/index.html', 'utf8');
template = handlebars.compile(template);

// Generate the static HTML pages in the next tick, i.e. after the other functions have
// been defined and handlebars helpers set up.
process.nextTick(function() {
	console.log('...Parsing your styleguide:');

	kss.traverse(argv.source, {
		multiline : true,
		markdown  : true,
		markup    : true,
		mask      : argv.mask
	}, function(err, guide) {
		if (err) throw err;

		styleguide = guide;

		var sections = styleguide.section('*.'),
			sectionCount = sections.length,
			sectionRoots = [],
			rootCount,
			currentRoot,
			childSections = [],
			i;

		console.log(styleguide.data.files.map(function(file) {
			return ' - ' + file;
		}).join('\n'));

		// Throw an error if no KSS sections are found in the source files.
		if (sectionCount === 0) {
			throw 'No KSS documentation discovered in source files.';
		}

		for (i = 0; i < sectionCount; i += 1) {
			// Register all the markup blocks as Handlebars partials.
			if (sections[i].markup()) {
				handlebars.registerPartial(sections[i].reference(), sections[i].markup());
			}

			// Accumulate all of the sections' first indexes
			// in case they don't have a root element.
			currentRoot = sections[i].reference().match(/[0-9]*\.?/)[0].replace('.', '');
			if (!~sectionRoots.indexOf(currentRoot)) {
				sectionRoots.push(currentRoot);
			}
		}
		sectionRoots.sort();

		console.log('...Generating styleguide sections:');

		// Now, group all of the sections by their root
		// reference, and make a page for each.
		rootCount = sectionRoots.length;
		for (i = 0; i < rootCount; i += 1) {
			childSections = styleguide.section(sectionRoots[i]+'.*');

			generatePage(styleguide, childSections, sectionRoots[i], sectionRoots);
		}

		// Generate the homepage.
		childSections = [];
		generatePage(styleguide, childSections, 'styleguide.homepage', sectionRoots);

		if (argv.css) {
			aggregateStylesheet(argv);
		}
	});
});

// Aggregate CSS files into a single "style.css" if required
aggregateStylesheet = function(argv) {
	var files;

	console.log('...Aggregating additional stylesheets:');

	files = [{
		files: Array.isArray(argv.css) ? argv.css : [argv.css],
		type: 'css'
	}];

	async.reduce(files, [], function (combined, group, next) {
		if (!group) return next(null, combined);

		async.map(group.files, function (filename, next) {
			var type = group.type,
				extension;

			console.log(' - ' + filename);

			return next(null, fs.readFileSync(filename, 'utf8'));

		}, function(err, output) {
			if (err) return next(err);
			combined += '\n';
			combined += output.join('\n');
			return next(null, combined);
		});
	}, function (err, combined) {
		if (err) throw err;
		saveStylesheet(combined, 'style.css');
	});
};

// Used by aggregateStylesheet to minify and then
// save its final buffer to a single CSS file.
saveStylesheet = function(buffer, filename) {
	buffer = new cleanCSS().minify(buffer.toString());
	filename = filename || 'style.css';
	fs.writeFileSync(
		argv.destination + '/public/' + filename,
		buffer, 'utf8'
	);
};

// Renders the handlebars template for a section and saves it to a file.
generatePage = function(styleguide, sections, root, sectionRoots) {
	var filename = '',
		homepageText = false;

	if (root == 'styleguide.homepage') {
		filename = 'index.html';
		console.log(' - homepage');
		// Ensure homepageText is a non-false value.
		try {
			homepageText = ' ' + marked(fs.readFileSync(argv.source + '/styleguide.md', 'utf8'));
		} catch (e) {
			homepageText = ' ';
			console.log('   ...no homepage content found: ', e.message);
		}
	}
	else {
		filename = 'section-'+root+'.html';
		console.log(
			' - section '+root+' [',
			styleguide.section(root) ? styleguide.section(root).header() : 'Unnamed',
			']'
		);
	}
	fs.writeFileSync(argv.destination + '/' + filename,
		template({
			styleguide: styleguide,
			sectionRoots: sectionRoots,
			sections: jsonSections(sections),
			rootNumber: root,
			argv: argv || {},
			overview: homepageText
		})
	);
};

// Convert an array of `KssSection` instances to a JSON object.
jsonSections = function(sections) {
	return sections.map(function(section) {
		return {
			header: section.header(),
			description: section.description(),
			reference: section.reference(),
			depth: section.data.refDepth,
			deprecated: section.deprecated(),
			experimental: section.experimental(),
			modifiers: jsonModifiers(section.modifiers())
		};
	});
};

// Convert an array of `KssModifier` instances to a JSON object.
jsonModifiers = function(modifiers) {
	return modifiers.map(function(modifier) {
		return {
			name: modifier.name(),
			description: modifier.description(),
			className: modifier.className()
		};
	});
};

// Load custom Handlebars helpers.
if (fs.existsSync(argv.helpers)) {
	var helperFiles = fs.readdirSync(argv.helpers);

	helperFiles.forEach(function(fileName) {
		if (path.extname(fileName) !== '.js') {
			return;
		}
		var helper = require(argv.helpers + '/' + fileName);
		if (typeof helper.register === 'function') {
			helper.register(handlebars);
		}
	});
}

/**
 * Returns a single section, found by its reference number
 * @param  {String|Number} reference The reference number to search for.
 */
handlebars.registerHelper('section', function(reference, options) {
	var section = styleguide.section(reference);

	return section ? options.fn(section.data) : false;
});

/**
 * Loop over a section query. If a number is supplied, will convert into
 * a query for all children and descendants of that reference.
 * @param  {Mixed} query The section query
 */
handlebars.registerHelper('eachSection', function(query, options) {
	var buffer = '',
		sections,
		i, l;

	if (!query.match(/x|\*/g)) {
		query = new RegExp('^' + query + '$|^' + query + "\\..*");
	}
	sections = styleguide.section(query);
	if (!sections) return '';

	l = sections.length;
	for (i = 0; i < l; i += 1) {
		buffer += options.fn(sections[i].data);
	}

	return buffer;
});

/**
* If the template exists as *reference*.html in the templates folder, inject it.
*/
handlebars.registerHelper('sectionTemplate', function(options) {
	var template;

	try {
		template = fs.readFileSync(argv.template + '/' + this.reference + '.hbs', 'utf8');
	} catch (e) {
		return;
	}

	console.log("...injecting template for section " + this.reference);

	return handlebars.compile(template)(this);
});

/**
 * Loop over each section root, i.e. each section only one level deep.
 */
handlebars.registerHelper('eachRoot', function(options) {
	var buffer = '',
		sections,
		i, l;

	sections = styleguide.section('x');
	if (!sections) return '';

	l = sections.length;
	for (i = 0; i < l; i += 1) {
		buffer += options.fn(sections[i].data);
	}

	return buffer;
});

/**
 * Equivalent to "if the current section is X levels deep". e.g:
 *
 * {{#ifDepth 1}}
 * 	 ROOT ELEMENTS ONLY
 * 	{{else}}
 * 	 ANYTHING ELSE
 * {{/ifDepth}}
 */
handlebars.registerHelper('ifDepth', function(depth, options) {
	if (!this.refDepth) {
		return '';
	}
	return (depth == this.refDepth) ? options.fn(this) : options.inverse(this);
});

/**
 * Equivalent to "unless the current section is X levels deep". e.g:
 *
 * {{#unlessDepth 1}}
 * 	 ANYTHING ELSE
 * 	{{else}}
 * 	 ROOT ELEMENTS ONLY
 * {{/unlessDepth}}
 */
handlebars.registerHelper('unlessDepth', function(depth, options) {
	if (!this.refDepth) {
		return '';
	}
	return (depth == this.refDepth) ? options.inverse(this) : options.fn(this);
});

/**
 * Similar to the {#eachSection} helper, however will loop over each modifier
 * @param  {Object} section Supply a section object to loop over it's modifiers. Defaults to the current section.
 */
handlebars.registerHelper('eachModifier', function() {
	var modifiers,
		options = arguments[arguments.length - 1],
		buffer = '',
		i, l;

	// Default to current modifiers, but allow supplying a custom section.
	modifiers = (arguments.length > 1 && arguments[0].data) ? arguments[0].data.modifiers : this.modifiers;

	if (!modifiers) return '';

	l = modifiers.length;
	for (i = 0; i < l; i++) {
		buffer += options.fn(modifiers[i].data || '');
	}
	return buffer;
});

/**
 * Outputs the current section's or modifier's markup.
 */
handlebars.registerHelper('markup', function() {
	var section,
		modifier,
		template,
		data = {};

	if (!this) {
		return '';
	}

	// Determine if the element is a section object or a modifier object.
	if (this.modifiers) {
		// If this is the section object, use the default markup without a modifier class.
		section = new kss.KssSection(this);
		data.modifier_class = '';
	}
	else {
		// If this is the markup object, find the modifier class and the section object.
		modifier = new kss.KssModifier(this);
		section = modifier.section();
		data.modifier_class = modifier.className();
	}

	// Compile the section's markup partial into a template.
	template = handlebars.compile('{{> "' + section.reference() + '"}}');

	// We don't wrap the rendered template in "new handlebars.SafeString()" since
	// we want the ability to display it as a code sample with {{ }} and as
	// rendered HTML with {{{ }}}.
	return template(data);
});

/**
 * Outputs a section or a modifier's markup, if possible.
 * @param  {Object} modifier Specify a particular modifier object. Defaults to the current modifier or section.
 */
handlebars.registerHelper('modifierMarkup', function() {
	// Fail if the template still uses modifierMarkup, since it is deprecated.
	// @TODO Remove this helper before the release of 2.0.0.
	throw 'The modifierMarkup Handlebars helper is deprecated; if your template has {{modifierMarkup}}, replace it with {{{markup}}}.';
});

process.on('exit', function() {
	if (!KSS_FAILED) {
		console.log('');
		console.log('Generation completed successfully!');
		console.log('');
	}
});

process.on('uncaughtException', function(err) {
	console.log('\nError during generation\n');

	if (err.message || err.stack) {
		console.log(err.message);
		console.log(err.stack);
	}
	else
		console.log(err);

	KSS_FAILED = true;
	process.exit(1);
});
