var KssStyleguide, sectionQueryMatch;

/**
 * An instance of this class is returned on finishing `kss.traverse`.
 * Exposes convenience methods for interpreting data.
 *
 * @param {Object} data The data object generated by traverse.
 */
module.exports = KssStyleguide = function (data) {
	if (!(this instanceof KssStyleguide)) {
		return new KssStyleguide();
	}
	this.data = data || {};
	this.init();
};

KssStyleguide.prototype.init = function () {

};

KssStyleguide.prototype.section = function(query) {
	var i, l = this.data.sections.length,
		current, isExact = false,
		sections = [];

	if (!query) {
		return this.section(/.+/);
	}

	// Exact Queries
	if (typeof query === 'string') {
		// Check first if we have a direct reference, then 
		if (this.data.section_refs && this.data.section_refs[query]) {
			return this.data.section_refs[query];
		} else {
		}
	}

	// If recieving a n.x or n.* query, convert it
	// to regex for general search
	if (!(query instanceof RegExp)) {
		query = new RegExp(
			query
			 .replace(/\*/g, '([\\w]\\.?)*')
			 .replace(/x/g, '[\\w]*')
		);
	}

	// General (regex) search
	for (i = 0; i < l; i += 1) {
		current = this.data.sections[i];
		if (sectionQueryMatch(current.data.reference, query)) {
			sections.push(current);
		}
	}

	if (!sections) {
		return false;
	}

	// Sorts results based on reference number.
	return sections.sort(function(a, b) {
		var refsA = a.data.reference.split('.'),
			refsB = b.data.reference.split('.'),
			rLengthA = refsA.length,
			rLengthB = refsB.length,
			i, l = Math.max(refsA.length, refsB.length);

		for (i = 0; i < l; i += 1) {
			if (refsA[i] && refsB[i]) {
				if (refsA[i] != refsB[i]) {
					return refsA[i] - refsB[i];
				}
			} else {
				return refsA[i] ? +1 : -1;
			}
		}

		return 0;
	});
};

sectionQueryMatch = function(reference, query) {
	var match = reference.match(query);
	return match && match[0] === reference;
};